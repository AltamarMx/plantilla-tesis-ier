%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.95a Copyright 2005 Radical Eye Software
%%Title: fig-bifurcacion-rounded.dvi
%%BoundingBox: 120 574 482 684
%%DocumentFonts: CMR9 CMMI9 CMSY6 CMMI6
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -E fig-bifurcacion-rounded -o
%+ fig-bifurcacion-rounded.eps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2007.05.17:1830
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
%!
% PostScript prologue for pstricks.tex.
% Version 97 patch 4, 04/05/10
% For distribution, see pstricks.tex.
%
/tx@Dict 200 dict def tx@Dict begin
/ADict 25 dict def
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Atan { /atan load stopped { pop pop 0 } if } def
/Div { dup 0 eq { pop } { div } ifelse } def
/NET { neg exch neg exch T } def
/Pyth { dup mul exch dup mul add sqrt } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def }
def
/PathLength { flattenpath /z 0 def { /y1 ED /x1 ED /y2 y1 def /x2 x1 def
} { /y ED /x ED PathLength@ } {} { /y y2 def /x x2 def PathLength@ }
/pathforall load stopped { pop pop pop pop } if z } def
/STP { .996264 dup scale } def
/STV { SDict begin normalscale end STP  } def
%
%%-------------- DG begin patch 15 ---------------%%
%/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
%PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
%mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
%/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
%0 } ifelse setdash stroke } def
/DashLine {
  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def PathLength } ifelse
  /b ED /x1 ED /y1 ED /x ED /y ED 
  /z y x add y1 add x1 add def
  /Coef b a .5 sub 2 mul y mul sub z Div round 
  z mul a .5 sub 2 mul y mul add b exch Div def 
  /y y Coef mul def /x x Coef mul def /y1 y1 Coef mul def /x1 x1 Coef mul def
  x1 0 gt y1 0 gt x 0 gt y 0 gt and { [ y x y1 x1 ] 1 a sub y mul}
  { [ 1 0] 0 } ifelse setdash stroke
} def
%%-------------- DG end patch 15 ---------------%%
/DotLine { /b PathLength def /a ED /z ED /y CLW def /z y z add def a 0 gt
{ /b b a div def } { a 0 eq { /b b y sub def } { a -3 eq { /b b y add
def } if } ifelse } ifelse [ 0 b b z Div round Div dup 0 le { pop 1 } if
] a 0 gt { 0 } { y 2 div a -2 gt { neg } if } ifelse setdash 1
setlinecap stroke } def
/LineFill { gsave abs CLW add /a ED a 0 dtransform round exch round exch
2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
% DG/SR modification end
Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
% def
a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
pop pop } def
% DG/SR modification end
/BeginArrow { ADict begin /@mtrx CM def gsave 2 copy T 2 index sub neg
exch 3 index sub exch Atan rotate newpath } def
/EndArrow { @mtrx setmatrix CP grestore end } def
/Arrow { CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
scale } if w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill
grestore } def
/Tbar { CLW mul add /z ED z -2 div CLW 2 div moveto z 0 rlineto stroke 0
CLW moveto } def
/Bracket { CLW mul add dup CLW sub 2 div /x ED mul CLW add /y ED /z CLW 2
div def x neg y moveto x neg CLW 2 div L x CLW 2 div L x y L stroke 0
CLW moveto } def
/RoundBracket { CLW mul add dup 2 div /x ED mul /y ED /mtrx CM def 0 CLW
2 div T x y mul 0 ne { x y scale } if 1 1 moveto .85 .5 .35 0 0 0
curveto -.35 0 -.85 .5 -1 1 curveto mtrx setmatrix stroke 0 CLW moveto }
def
/SD { 0 360 arc fill } def
/EndDot { { /z DS def } { /z 0 def } ifelse /b ED 0 z DS SD b { 0 z DS
CLW sub SD } if 0 DS z add CLW 4 div sub moveto } def
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
/closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
load } if ] cvx newpath 3 1 roll T exec } def
/NArray { aload length 2 div dup dup cvi eq not { exch pop } if /n exch
cvi def } def
/NArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop } if
f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
/Line { NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub
def n { Lineto } repeat CP 4 2 roll ArrowB L pop pop } if } def
/Arcto { /a [ 6 -2 roll ] cvx def a r /arcto load stopped { 5 } { 4 }
ifelse { pop } repeat a } def
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
Lineto pop pop closepath } ifelse } def
/Diamond { /mtrx CM def T rotate /h ED /w ED dup 0 eq { pop } { CLW mul
neg /d ED /a w h Atan def /h d a sin Div h add def /w d a cos Div w add
def } ifelse mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2
div /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup
CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
div dup cos exch sin Div mul sub def mark 0 d w neg d 0 h w d 0
d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
setmatrix pop } def
% DG/SR modification end
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CC { /l0 l1 def /x1 x dx sub def /y1 y dy sub def /dx0 dx1 def /dy0 dy1
def CCA /dx dx0 l1 c exp mul dx1 l0 c exp mul add def /dy dy0 l1 c exp
mul dy1 l0 c exp mul add def /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos
abs b exp a mul dx dy Pyth Div 2 div def /x2 x l0 dx mul m mul sub def
/y2 y l0 dy mul m mul sub def /dx l1 dx mul m mul neg def /dy l1 dy mul
m mul neg def } def
/IC { /c c 1 add def c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if }
ifelse /a a 2 mul 3 div 45 cos b exp div def CCA /dx 0 def /dy 0 def }
def
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
/OpenCurve { NArray n 3 lt { n { pop pop } repeat } { BOC /n n 3 sub def
    n { NC } repeat EOC } ifelse } def
/AltCurve { { false NArray n 2 mul 2 roll [ n 2 mul 3 sub 1 roll ] aload
/Points ED n 2 mul -2 roll } { false NArray } ifelse n 4 lt { n { pop
pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse } def
/ClosedCurve { NArray n 3 lt { n { pop pop } repeat } { n 3 gt {
CheckClosed } if 6 copy n 2 mul 6 add 6 roll IC CC x y moveto n { NC }
repeat closepath pop pop } ifelse } def
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore }
def
/FontDot { DS 2 mul dup matrix scale matrix concatmatrix exch matrix
rotate matrix concatmatrix exch findfont exch makefont setfont } def
/Rect { x1 y1 y2 add 2 div moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto
x1 y1 lineto closepath } def
/OvalFrame { x1 x2 eq y1 y2 eq or { pop pop x1 y1 moveto x2 y2 L } { y1
y2 sub abs x1 x2 sub abs 2 copy gt { exch pop } { pop } ifelse 2 div
exch { dup 3 1 roll mul exch } if 2 copy lt { pop } { exch pop } ifelse
/b ED x1 y1 y2 add 2 div moveto x1 y2 x2 y2 b arcto x2 y2 x2 y1 b arcto
x2 y1 x1 y1 b arcto x1 y1 x1 y2 b arcto 16 { pop } repeat closepath }
ifelse } def
/Frame { CLW mul /a ED 3 -1 roll 2 copy gt { exch } if a sub /y2 ED a add
/y1 ED 2 copy gt { exch } if a sub /x2 ED a add /x1 ED 1 index 0 eq {
pop pop Rect } { OvalFrame } ifelse } def
/BezierNArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop
} if n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat f { ]
aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
/OpenBezier { BezierNArray n 1 eq { pop pop } { ArrowA n 4 sub 3 idiv { 6
2 roll 4 2 roll curveto } repeat 6 2 roll 4 2 roll ArrowB curveto }
ifelse } def
/ClosedBezier { BezierNArray n 1 eq { pop pop } { moveto n 1 sub 3 idiv {
6 2 roll 4 2 roll curveto } repeat closepath } ifelse } def
/BezierShowPoints { gsave Points aload length 2 div cvi /n ED moveto n 1
sub { lineto } repeat CLW 2 div SLW [ 4 4 ] 0 setdash stroke grestore }
def
/Parab { /y0 exch def /x0 exch def /y1 exch def /x1 exch def /dx x0 x1
sub 3 div def /dy y0 y1 sub 3 div def x0 dx sub y0 dy add x1 y1 ArrowA
x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB curveto /Points [ x1 y1 x0
y0 x0 2 mul x1 sub y1 ] def } def
/Grid { newpath /a 4 string def /b ED /c ED /n ED cvi dup 1 lt { pop 1 }
if /s ED s div dup 0 eq { pop 1 } if /dy ED s div dup 0 eq { pop 1 } if
/dx ED dy div round dy mul /y0 ED dx div round dx mul /x0 ED dy div
round cvi /y2 ED dx div round cvi /x2 ED dy div round cvi /y1 ED dx div
round cvi /x1 ED /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def /w x2 x1 sub
0 gt { 1 } { -1 } ifelse def b 0 gt { /z1 b 4 div CLW 2 div add def
/Helvetica findfont b scalefont setfont /b b .95 mul CLW 2 div add def }
if systemdict /setstrokeadjust known { true setstrokeadjust /t { } def }
{ /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
exch itransform } bind def } ifelse gsave n 0 gt { 1 setlinecap [ 0 dy n
div ] dy n div 2 div setdash } { 2 setlinecap } ifelse /i x1 def /f y1
dy mul n 0 gt { dy n div 2 div h mul sub } if def /g y2 dy mul n 0 gt {
dy n div 2 div h mul add } if def x2 x1 sub w mul 1 add dup 1000 gt {
pop 1000 } if { i dx mul dup y0 moveto b 0 gt { gsave c i a cvs dup
stringwidth pop /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse h 0 gt {b neg}
{z1} ifelse rmoveto show grestore } if dup t f moveto g t L stroke /i i
w add def } repeat grestore gsave n 0 gt
% DG/SR modification begin - Nov. 7, 1997 - Patch 1
%{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
{ 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
% DG/SR modification end
{ 2 setlinecap } ifelse /i y1 def /f x1 dx mul
n 0 gt { dx n div 2 div w mul sub } if def /g x2 dx mul n 0 gt { dx n
div 2 div w mul add } if def y2 y1 sub h mul 1 add dup 1000 gt { pop
1000 } if { newpath i dy mul dup x0 exch moveto b 0 gt { gsave c i a cvs
dup stringwidth pop /z2 ED w 0 gt {z1 z2 add neg} {z1} ifelse h 0 gt
{z1} {b neg} ifelse rmoveto show grestore } if dup f exch t moveto g
exch t L stroke /i i h add def } repeat grestore } def
/ArcArrow { /d ED /b ED /a ED gsave newpath 0 -1000 moveto clip newpath 0
1 0 0 b grestore c mul /e ED pop pop pop r a e d PtoC y add exch x add
exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
mul neg d } def
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
/RotBegin { tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 }
def } if /TMatrix [ TMatrix CM ] cvx def /a ED a Rot /RAngle [ RAngle
dup a add ] cvx def } def
/RotEnd { /TMatrix [ TMatrix setmatrix ] cvx def /RAngle [ RAngle pop ]
cvx def } def
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
/Uput { /a ED add 2 div /h ED 2 div /w ED /s a sin def /c a cos def /b s
abs c abs 2 copy gt dup /q ED { pop } { exch pop } ifelse def /w1 c b
div w mul def /h1 s b div h mul def q { w1 abs w sub dup c mul abs } {
h1 abs h sub dup s mul abs } ifelse } def
/UUput { /z ED abs /y ED /x ED q { x s div c mul abs y gt } { x c div s
mul abs y gt } ifelse { x x mul y y mul sub z z mul add sqrt z add } { q
{ x s div } { x c div } ifelse abs } ifelse a PtoC h1 add exch w1 add
exch } def
/BeginOL { dup (all) eq exch TheOL eq or { IfVisible not { Visible
/IfVisible true def } if } { IfVisible { Invisible /IfVisible false def
} if } ifelse } def
/InitOL { /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
/Visible { CP OLUnit idtransform T moveto } def /Invisible { CP OLUnit
neg exch neg exch idtransform T moveto } def /BOL { BeginOL } def
/IfVisible true def } def
end
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
%!PS-Adobe-2.0
%%Title: Dot Font for PSTricks
%%Creator: Timothy Van Zandt <tvz@Princeton.EDU>
%%Creation Date: May 7, 1993
%% Version 97 patch 1, 99/12/16
%% Modified by Etienne Riga <etienne.riga@skynet.be> - Dec. 16, 1999
%% to add /Diamond, /SolidDiamond and /BoldDiamond
10 dict dup begin
  /FontType 3 def
  /FontMatrix [ .001 0 0 .001 0 0 ] def
  /FontBBox [ 0 0 0 0 ] def
  /Encoding 256 array def
  0 1 255 { Encoding exch /.notdef put } for
  Encoding
    dup (b) 0 get /Bullet put
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
% DG/SR modification end
  /Metrics 13 dict def
  Metrics begin
    /Bullet        1000   def
    /Circle        1000   def
    /BoldCircle    1000   def
    /SolidTriangle 1344   def
    /Triangle      1344   def
    /BoldTriangle  1344   def
    /SolidSquare    886   def
    /Square         886   def
    /BoldSquare     886   def
    /SolidPentagon 1093.2 def
    /Pentagon      1093.2 def
    /BoldPentagon  1093.2 def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /SolidDiamond  1008   def
    /Diamond       1008   def
    /BoldDiamond   1008   def
% DG/SR modification end
    /.notdef 0 def
  end
  /BBoxes 13 dict def
  BBoxes begin
    /Circle        { -550 -550 550 550 } def
    /BoldCircle    /Circle load def
    /Bullet        /Circle load def
    /Triangle      { -571.5 -330 571.5 660 } def
    /BoldTriangle  /Triangle load def
    /SolidTriangle /Triangle load def
    /Square        { -450 -450 450 450 } def
    /BoldSquare    /Square load def
    /SolidSquare   /Square load def
    /Pentagon      { -546.6 -465 546.6 574.7 } def
    /BoldPentagon  /Pentagon load def
    /SolidPentagon /Pentagon load def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /Diamond       { -428.5 -742.5 428.5 742.5 } def
    /BoldDiamond   /Diamond load def
    /SolidDiamond  /Diamond load def
% DG/SR modification end
    /.notdef { 0 0 0 0 } def
  end
  /CharProcs 20 dict def
  CharProcs begin
    /Adjust {
      2 copy dtransform floor .5 add exch floor .5 add exch idtransform
      3 -1 roll div 3 1 roll exch div exch scale
    } def
    /CirclePath    { 0 0 500 0 360 arc closepath } def
    /Bullet        { 500 500 Adjust CirclePath fill } def
    /Circle        { 500 500 Adjust CirclePath .9 .9 scale CirclePath
                     eofill } def
    /BoldCircle    { 500 500 Adjust CirclePath .8 .8 scale CirclePath
                     eofill } def
    /BoldCircle    { CirclePath .8 .8 scale CirclePath eofill } def
    /TrianglePath  { 0  660 moveto -571.5 -330 lineto 571.5 -330 lineto
                     closepath } def
    /SolidTriangle { TrianglePath fill } def
    /Triangle      { TrianglePath .85 .85 scale TrianglePath eofill } def
    /BoldTriangle  { TrianglePath .7 .7 scale TrianglePath eofill } def
    /SquarePath    { -450 450 moveto 450 450 lineto 450 -450 lineto
                     -450 -450 lineto closepath } def
    /SolidSquare   { SquarePath fill } def
    /Square        { SquarePath .89 .89 scale SquarePath eofill } def
    /BoldSquare    { SquarePath .78 .78 scale SquarePath eofill } def
    /PentagonPath  {
      -337.8 -465   moveto
       337.8 -465   lineto
       546.6  177.6 lineto
         0    574.7 lineto
      -546.6  177.6 lineto
      closepath
    } def
    /SolidPentagon { PentagonPath fill } def
    /Pentagon      { PentagonPath .89 .89 scale PentagonPath eofill } def
    /BoldPentagon  { PentagonPath .78 .78 scale PentagonPath eofill } def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /DiamondPath   { 0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto
                     428.5 0 lineto closepath } def
    /SolidDiamond  { DiamondPath fill } def
    /Diamond       { DiamondPath .85 .85 scale DiamondPath eofill } def
    /BoldDiamond   { DiamondPath .7 .7 scale DiamondPath eofill } def
% DG/SR modification end
    /.notdef { } def
  end
  /BuildGlyph {
    exch
    begin
      Metrics 1 index get exec 0
      BBoxes 3 index get exec
      setcachedevice
      CharProcs begin load exec end
    end
  } def
  /BuildChar {
    1 index /Encoding get exch get
    1 index /BuildGlyph get exec
  } bind def
end
/PSTricksDotFont exch definefont pop
%END pst-dots.pro

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.04, 2004/06/23 (adding %GradientCircle style - D.G.)
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 rotate
 /MidPoint ED
 /NumLines ED
 /LastBlue ED
 /LastGreen ED
  /LastRed ED
  /FirstBlue ED
  /FirstGreen ED
/FirstRed ED
% D.G. modification begin - Apr.  9, 1998
/GradientPosY ED
/GradientPosX ED
  /GradientScale ED
  /ifGradientCircle ED
% D.G. modification end
  % This avoids gaps due to rounding errors:
    clip
  pathbbox           %leave llx,lly,urx,ury on stack
% D.G. modification begin - Apr. 10, 1998
  4 copy /ury ED /urx ED /lly ED /llx ED
% D.G. modification end
  /y ED /x ED
% D.G. modification begin - Apr. 10, 1998
ifGradientCircle
   {0 GradientPosX eq
    {0 GradientPosX eq {2 copy translate} if} if}
   {2 copy translate} ifelse
% D.G. modification end
    y sub neg /y ED
  x sub neg /x ED  % This avoids gaps due to rounding errors:
  LastRed FirstRed add 2 div
   LastGreen FirstGreen add 2 div
  LastBlue FirstBlue add 2 div
    setrgbcolor
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {/YSizePerLine y NumLines div def
    /CurrentY y 2 div def
    /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def}
       {fill
    /YSizePerLine y NumLines div def
        /CurrentY 0 def
    /MidLine NumLines 1 MidPoint sub mul abs cvi def} ifelse
% DG modification end
  MidLine NumLines 2 sub gt
    { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
   ifelse
    MidLine 0 gt
      {
    /Red FirstRed def
       /Green FirstGreen def
           /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
    MidLine { GradientLoop } repeat
      } if
       MidLine NumLines lt
         {
    /Red LastRed def
       /Green LastGreen def
       /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoop } repeat  }
     if
     } def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      Red Green Blue setrgbcolor fill
      /CurrentY CurrentY YSizePerLine sub def
      /Blue Blue BlueIncrement add def
      /Green Green GreenIncrement add def
      /Red Red RedIncrement add def} if}   {0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
    Red Green Blue setrgbcolor fill    /CurrentY CurrentY YSizePerLine add def
    /Blue Blue BlueIncrement add def    /Green Green GreenIncrement add def
    /Red Red RedIncrement add def} ifelse% D.G. modification end
    }def
    end
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!
% PostScript prologue for pst-coil.tex.
% Version 97 patch 1, 98/06/02
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { /t ED t sin AspectSin mul t 180 div AspectCos mul add t cos
lineto } def
/Coil { /Inc ED dup sin /AspectSin ED cos /AspectCos ED /ArmB ED /ArmA ED
/h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED x0 y0 translate y1 y0 sub x1 x0
sub 2 copy Pyth /TotalLength ED Atan rotate /BeginAngle ArmA AspectCos
Div w h mul Div 360 mul def /EndAngle TotalLength ArmB sub AspectCos Div
w h mul Div 360 mul def 1 0 0 0 ArrowA ArmA 0 lineto /mtrx CM def w h
mul 2 Div w 2 Div scale BeginAngle Inc EndAngle { CoilLoop } for
EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
TotalLength 0 ArrowB lineto
pop pop pop pop } def
% DG/SR modification end
/AltCoil { /Inc ED dup sin /AspectSin ED cos /AspectCos ED /h ED /w ED
/EndAngle ED /BeginAngle ED /mtrx CM def w h mul 2 Div w 2 Div scale
BeginAngle sin AspectSin mul BeginAngle 180 div AspectCos mul add
BeginAngle cos /lineto load stopped { moveto } if BeginAngle Inc
EndAngle { CoilLoop } for EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { /ArmB ED /ArmA ED 2 div /w ED w mul /h ED /y1 ED /x1 ED /y0 ED
/x0 ED x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth /TotalLength ED
Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
sub 2 div dup ArmA add /ArmA ED ArmB add /ArmB ED /x ArmB h 2 div add
def mark 0 0 ArmB 0 n { x w /w w neg def /x x h add def } repeat
TotalLength ArmA sub 0 TotalLength 0 } def
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 97, 94/04/20; patched MV 10-09-99 00:36
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc
{
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow
{ /String exch def
  /CharCount 0 def
  String length
  { String CharCount 1 getinterval ShowChar
    /CharCount CharCount 1 add def
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar
{ /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def

end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
%!
% PostScript prologue for pst-node.tex.
% Version 97 patch 1, 97/05/09.
% For distribution, see pstricks.tex.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin /T /translate load def end
/NewNode { gsave /next ED dict dup 3 1 roll def exch { dup 3 1 roll def }
if begin tx@Dict begin STV CP T exec end /NodeMtrx CM def next end
grestore } def
/InitPnode { /Y ED /X ED /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
/InitCnode { /r ED /Y ED /X ED /NodePos { NodeSep r add dup Cos mul exch
Sin mul } def } def
/GetRnodePos { Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def
} ifelse Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def }
ifelse dx Sin mul abs dy Cos mul abs gt { dy Cos mul Sin div dy } { dx
dup Sin mul Cos Div } ifelse } def
/InitRnode { /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub
/u ED /NodePos { GetRnodePos } def } def
/DiaNodePos { w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
Cos mul exch Sin mul } def
/TriNodePos { Sin s lt { d NodeSep sub dup Cos mul Sin Div exch } { w h
mul w Sin mul h Cos abs mul add Div NodeSep add dup Cos mul exch Sin mul
} ifelse } def
/InitTriNode { sub 2 div exch 2 div exch 2 copy T 2 copy 4 index index /d
ED pop pop pop pop -90 mul rotate /NodeMtrx CM def /X 0 def /Y 0 def d
sub abs neg /d ED d add /h ED 2 div h mul h d sub Div /w ED /s d w Atan
sin def /NodePos { TriNodePos } def } def
/OvalNodePos { /ww w NodeSep add def /hh h NodeSep add def Sin ww mul Cos
hh mul Atan dup cos ww mul exch sin hh mul } def
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
/XYPos { dup sin exch cos Do /Cos ED /Sin ED /Dist ED Cos 0 gt { Dist
Dist Sin mul Cos div } { Cos 0 lt { Dist neg Dist Sin mul Cos div neg }
{ 0 Dist Sin mul } ifelse } ifelse Do } def
/GetEdge { dup 0 eq { pop begin 1 0 NodeMtrx dtransform CM idtransform
exch atan sub dup sin /Sin ED cos /Cos ED /NodeSep ED NodePos NodeMtrx
dtransform CM idtransform end } { 1 eq {{exch}} {{}} ifelse /Do ED pop
XYPos } ifelse } def
/AddOffset { 1 index 0 eq { pop pop } { 2 copy 5 2 roll cos mul add 4 1
roll sin mul sub exch } ifelse } def
/GetEdgeA { NodeSepA AngleA NodeA NodeSepTypeA GetEdge OffsetA AngleA
AddOffset yA add /yA1 ED xA add /xA1 ED } def
/GetEdgeB { NodeSepB AngleB NodeB NodeSepTypeB GetEdge OffsetB AngleB
AddOffset yB add /yB1 ED xB add /xB1 ED } def
/GetArmA { ArmTypeA 0 eq { /xA2 ArmA AngleA cos mul xA1 add def /yA2 ArmA
AngleA sin mul yA1 add def } { ArmTypeA 1 eq {{exch}} {{}} ifelse /Do ED
ArmA AngleA XYPos OffsetA AngleA AddOffset yA add /yA2 ED xA add /xA2 ED
} ifelse } def
/GetArmB { ArmTypeB 0 eq { /xB2 ArmB AngleB cos mul xB1 add def /yB2 ArmB
AngleB sin mul yB1 add def } { ArmTypeB 1 eq {{exch}} {{}} ifelse /Do ED
ArmB AngleB XYPos OffsetB AngleB AddOffset yB add /yB2 ED xB add /xB2 ED
} ifelse } def
/InitNC { /b ED /a ED /NodeSepTypeB ED /NodeSepTypeA ED /NodeSepB ED
/NodeSepA ED /OffsetB ED /OffsetA ED tx@NodeDict a known tx@NodeDict b
known and dup { /NodeA a load def /NodeB b load def NodeA GetCenter /yA
ED /xA ED NodeB GetCenter /yB ED /xB ED } if } def
/LPutLine { 4 copy 3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 1 t sub
mul 3 1 roll 1 t sub mul 4 1 roll t mul add /Y ED t mul add /X ED } def
/LPutLines { mark LPutVar counttomark 2 div 1 sub /n ED t floor dup n gt
{ pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse cvi 2 mul { pop
} repeat LPutLine cleartomark } def
/BezierMidpoint { /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED
/t ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3
mul cx sub def /by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx
sub def /ay y3 y0 sub cy sub by sub def ax t 3 exp mul bx t t mul mul
add cx t mul add x0 add ay t 3 exp mul by t t mul mul add cy t mul add
y0 add 3 ay t t mul mul mul 2 by t mul mul add cy add 3 ax t t mul mul
mul 2 bx t mul mul add cx add atan /NAngle ED /Y ED /X ED } def
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
/NCLine { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB lineto pop pop
end } def
/NCLines { false NArray n 0 eq { NCLine } { 2 copy yA sub exch xA sub
Atan /AngleA ED n 2 mul dup index exch index yB sub exch xB sub Atan
/AngleB ED GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1
yA1 ] cvx def mark LPutVar tx@Dict begin false Line end /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
ifelse } def
/NCCurve { GetEdgeA GetEdgeB xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
/NCAngles { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform pop xB2 yB2 mtrx transform exch pop mtrx
itransform /y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA2
yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end /LPutVar [ xB1
yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def /LPutPos { LPutLines } def
/HPutPos { HPutLines } def /VPutPos { VPutLines } def } def
/NCAngle { GetEdgeA GetEdgeB GetArmB /mtrx AngleA matrix rotate def xB2
yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
/y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA1 yA1
tx@Dict begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCBar { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate def
xA2 yA2 mtrx itransform pop xB2 yB2 mtrx itransform pop sub dup 0 mtrx
transform 3 -1 roll 0 gt { /yB2 exch yB2 add def /xB2 exch xB2 add def }
{ /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse mark ArmB
0 ne { xB1 yB1 } if xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict
begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx
def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCDiag { GetEdgeA GetEdgeB GetArmA GetArmB mark ArmB 0 ne { xB1 yB1 } if
xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end
/LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCDiagg { GetEdgeA GetArmA yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
GetEdgeB mark xB1 yB1 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin
false Line end /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCLoop { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED /xB3 xB2 yB2
mtrx transform pop def xB3 yA3 mtrx itransform /yB3 ED /xB3 ED xA3 yA3
mtrx itransform /yA3 ED /xA3 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2
xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false
Line end /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
/NCCircle { NodeSepA 0 NodeA 0 GetEdge pop 2 div dup 2 exp r
r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
mul add dup 5 1 roll 90 sub PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
% DG/SR modification end
} def /HPutPos { LPutPos } def /VPutPos { LPutPos } def r AngleA 90 sub a add
AngleA 270 add a sub tx@Dict begin /angleB ED /angleA ED /r ED /c 57.2957 r
Div def /y ED /x ED } def
/NCBox { /d ED /h ED /AngleB yB yA sub xB xA sub Atan def /AngleA AngleB
180 add def GetEdgeA GetEdgeB /dx d AngleB sin mul def /dy d AngleB cos
mul neg def /hx h AngleB sin mul neg def /hy h AngleB cos mul def
/LPutVar [ xA1 hx add yA1 hy add xB1 hx add yB1 hy add xB1 dx add yB1 dy
add xA1 dx add yA1 dy add ] cvx def /LPutPos { LPutLines } def /HPutPos
{ xB yB xA yA LPutLine } def /VPutPos { HPutPos } def mark LPutVar
tx@Dict begin false Polygon end } def
/NCArcBox { /l ED neg /d ED /h ED /a ED /AngleA yB yA sub xB xA sub Atan
def /AngleB AngleA 180 add def /tA AngleA a sub 90 add def /tB tA a 2
mul add def /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
/x0 xA r tA cos mul add def /y0 yA r tA sin mul add def /c 57.2958 r div
def /AngleA AngleA a sub 180 add def /AngleB AngleB a add 180 add def
GetEdgeA GetEdgeB /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul
sub def /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def l 0
eq { x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn }
{ x0 y0 translate /tA AngleA l c mul add def /tB AngleB l c mul sub def
0 0 r h add tA tB arc r h add AngleB PtoC r d add AngleB PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r d add tB PtoC l arcto 4 { pop } repeat 0
0 r d add tB tA arcn r d add AngleA PtoC r h add AngleA PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r h add tA PtoC l arcto 4 { pop } repeat }
ifelse closepath /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def /LPutPos
{ LPutVar /d ED /h ED /AngleB ED /AngleA ED /r ED /y0 ED /x0 ED t 1 le {
r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC }
{ t 2 lt { /NAngle AngleB 180 add def r 2 t sub h mul t 1 sub d mul add
add AngleB PtoC } { t 3 lt { r d add AngleB 3 t sub mul AngleA 2 t sub
mul add dup 90 sub /NAngle ED PtoC } { /NAngle AngleA 180 add def r 4 t
sub d mul t 3 sub h mul add add AngleA PtoC } ifelse } ifelse } ifelse
y0 add /Y ED x0 add /X ED } def /HPutPos { LPutPos } def /VPutPos {
LPutPos } def } def
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
/LPutCoor { NAngle tx@Dict begin /NAngle ED end gsave CM STV CP Y sub neg
exch X sub neg exch moveto setmatrix CP grestore } def
/LPut { tx@NodeDict /LPutPos known { LPutPos } { CP /Y ED /X ED /NAngle 0
def } ifelse LPutCoor  } def
/HPutAdjust { Sin Cos mul 0 eq { 0 } { d Cos mul Sin div flag not { neg }
if h Cos mul Sin div flag { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { r add neg } { l add } ifelse X add /X ED }
def
/VPutAdjust { Sin Cos mul 0 eq { 0 } { l Sin mul Cos div flag { neg } if
r Sin mul Cos div flag not { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { d add } { h add neg } ifelse Y add /Y ED }
def
end
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: CMMI6
%!PS-AdobeFont-1.1: CMMI6 1.100
%%CreationDate: 1996 Jul 23 07:53:52
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.100) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMMI6) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
end readonly def
/FontName /CMMI6 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 111 /o put
readonly def
/FontBBox{11 -250 1241 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0529731C99A784CCBE85B4993B2EEBDE
3B12D472B7CF54651EF21185116A69AB1096ED4BAD2F646635E019B6417CC77B
532F85D811C70D1429A19A5307EF63EB5C5E02C89FC6C20F6D9D89E7D91FE470
B72BEFDA23F5DF76BE05AF4CE93137A219ED8A04A9D7D6FDF37E6B7FCDE0D90B
986423E5960A5D9FBB4C956556E8DF90CBFAEC476FA36FD9A5C8175C9AF513FE
D919C2DDD26BDC0D99398B9F4D03D6A8F05B47AF95EF28A9C561DBDC98C47CF5
5250011D19E9366EB6FD153D3A100CAA6212E3D5D93990737F8D326D347B7EDC
4391C9DF440285B8FC159D0E98D4258FC57892DDF0342CA1080743A076089583
6AD6FB2DC4C13F077F17789476E48402796E685107AF60A63FB0DE0266D55CF1
8D0AD65B9342CB686E564758C96164FFA711B11C1CE8C726F3C7BB1044BBD283
9AA4675747DF61E130A55E297CA5F0182A3F12F9085AF2F503481071724077A9
387E27879A9649AD5F186F33500FAC8F7FA26634BDCE1221EC0ED0E359E5EA5E
6166526FEB90C30D30099FBDC1BC2F9B62EFEEC48345160804AA98F8D0AA54B7
A480E715426651865C8E444EDB798C7E11040AF6E5A7ED1888653C6DBF5E6169
70BCD9C063B63B561EF165BF3AF11F8E519F37C6FDA2827685739DE2C48B5ADE
EE84F067D704D4511DBFA49E166D543CFD9ECD7417055D8A827F51E087CD2927
BAFC7E6CFBD70B0FE969F890A11149D3D44D422C3370495DA9951AEE7253A49F
3A9444C8CD9158D84117299F7F2332FEB0F94E6ED8BC7AA789A3219BC2F227D3
3B5BC75FB53B55D72AF4A6A7BB613FA235B11BB37D059FD87127CEF73D5B3FBF
9F91ABAD78BD9240BD9525EBA78095EA0BDB25D1A19E876F292882EAD5619D46
D20317A345D931F4FF4EAE6216C27044CBA525E3B917CEA25A04C120466C4B93
FC720E6BA832A06CCA0A3916CEF0968D49085AEBD243C41A448289A6F05CE3F5
79148DC112A3CC7E8FF810B8C1A09E05F496C0F1EBA334E42E05C376C98F5F69
C06C71BFC0A2F3AC9951CFBB143C66FB84F9C4ED27DF70869352D61BD5E11508
0797B87C71AC58D7C35AB3247575482E538773F05A104796EB1C5263CCE8F494
FA03858632DDEFC989E9994E41A6D4FA4322D42DB7168FA304A1843CDBA42D62
D19BDAE119E0257776E57B83DD8A96528DE2EB24E8F04D69186802D29FD6CCAF
A1D35B15D061A8995C2DD7FFC7F50E8BE1257D8D183373A02E07D1755988EC0B
751590D700D89BB738A54AAD12919B23F7957C18C4FA21A5EB59A234F29DCF56
757D8DAB83CA0683CA0DF8BCF0AF101366D636638052E724FCFF279041B0D5D0
5C65BAEEE51B3F5BF6E8C2D7542C3E05F564E3B933D25C3A51A7F072B23ED0E8
6D950786EB75DB17C6D07CC0C2DA9D6C33BCAB4CBE200D09325DB2B189A59CDD
2D5EBFB62CEE0978377497195C6A333FA1
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMSY6
%!PS-AdobeFont-1.1: CMSY6 1.0
%%CreationDate: 1991 Aug 15 07:21:34
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMSY6) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.035 def
/isFixedPitch false def
end readonly def
/FontName /CMSY6 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 3 /asteriskmath put
readonly def
/FontBBox{-4 -948 1329 786}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052F09F9C8ADE9D907C058B87E9B6964
7D53359E51216774A4EAA1E2B58EC3176BD1184A633B951372B4198D4E8C5EF4
A213ACB58AA0A658908035BF2ED8531779838A960DFE2B27EA49C37156989C85
E21B3ABF72E39A89232CD9F4237FC80C9E64E8425AA3BEF7DED60B122A52922A
221A37D9A807DD01161779DDE7D5FC1B2109839E5B52DFB7605D7BA557CC35D6
49F6EB651B83771034BA0C39DB8D426A24543EF4529E2D939125B5157482688E
9045C2242F4AFA4C489D975C029177CD6497EACD181FF151A45F521A4C4043C2
1F3E76EF5B3291A941583E27DFC68B9211105827590393ABFB8AA4D1623D1761
6AC0DF1D3154B0277BE821712BE7B33385E7A4105E8F3370F981B8FE9E3CF3E0
007B8C9F2D934F24D591C330487DDF179CECEC5258C47E4B32538F948AB00673
F9D549C971B0822056B339600FC1E3A5E51844CC8A75B857F15E7276260ED115
C5FD550F53CE5583743B50B0F9B7C4F836DEF7499F439A6EBE9BF559D2EE0571
CE54AEC463244B0F8EAB9E96CB18BD39259CC1FEC10F47FB56A38588CE634209
8F77258607212EE1DCA4F0667B152875B2CF5AC44B930B888ACD9D4B55662542
71239286D82E14CAABE7276AB199E2429C4C3BC32713106A10F5F16C8045A580
86EE21E7783B70FAE03D8D47B5AA13A881D478232DD65DBCD1EB9811C440E362
527EF73FC86FE664ACED80DCD6806CFD932BDEE102B89C22F423992249FC2273
F39C59AEF75B2088527AA973C71A6B134D26EF1ABAB75721971A0E4E52639DA9
2E1C3B2A6FB552CA834F6443E0628DD9CE69E92DA0B9B8ACAF3641FA0A7F1126
8DF8803E683ACCCCDE88C9F6C1838BCE7E8B56A0BC8C5F0300D81479A5087FFD
B8B66527B87F7977C31A54E0506C6D33EBC902841AB7B8D75BC8ADE5397905EF
BCB96AE4B57D308DCF0F74A93177F2DDF3486642A43834DB5B123CFA402E4BA1
6EB4C27AF21C96932E05B79CF951354FF66668C6503CA6FD2089A91A8D
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMMI9
%!PS-AdobeFont-1.1: CMMI9 1.100
%%CreationDate: 1996 Jul 23 07:53:55
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.100) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMMI9) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
end readonly def
/FontName /CMMI9 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 80 /P put
dup 120 /x put
readonly def
/FontBBox{-29 -250 1075 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0529731C99A784CCBE85B4993B2EEBDE
3B12D472B7CF54651EF21185116A69AB1096ED4BAD2F646635E019B6417CC77B
532F85D811C70D1429A19A5307EF63EB5C5E02C89FC6C20F6D9D89E7D91FE470
B72BEFDA23F5DF76BE05AF4CE93137A219ED8A04A9D7D6FDF37E6B7FCDE0D90B
986423E5960A5D9FBB4C956556E8DF90CBFAEC476FA36FD9A5C8175C9AF513FE
D919C2DDD26BDC0D99398B9F4D03D5993DFC0930297866E1CD0A319B6B1FD958
9E394A533A081C36D6F5CA5FED4F9AC9ADE41E04F9FC52E758C9F45A92BED935
86F9CFDB57732045913A6422AD4206418610C81D882EE493DE9523CC1BFE1505
DD1390B19BC1947A01B93BC668BE9B2A0E69A968554239B88C00AF9FBDF09CCD
67D3B2094C11A04762FE8CC1E91D020A28B3C122D24BEAACF82313F4604F2FEF
6E176D730A879BE45DD0D4996EF0247AEB1CA0AB08FF374D99F06D47B36F9554
FAD9A2D3CE451B7791C3709D8A1DDDEFBD840C1B42AB824D5A0DFF0E0F15B0B7
22AEEB877FF489581DA6FA8DA64944555101EB16F7AB0B717E148B7B98D8DBFD
730C52937E226545CF8DC3E07C5BA30739BAFCD0F2B44275A6D503F582C0FB4F
449963D0AD2FAFDE33BA3D77BCA9D1DF878DDAFCA2E22CC4BACD542B282164C7
97C2BDE318AF9D501CA21F6E662E7AAB75A5F24D2C182E598D175D44E88AB19A
E7CD59584F95B389183EE21B525BF52A3F23C0FE5383A5565A19361D716F508C
AAB78411CA5A4D27552CC1C435760D5A89D535B71C593E755C616661363308DA
A683F54ED0C23FB2C225A008392B0B719F66F11A946A090B7C00B662A3C69599
B4ECB0CC70C85C4BBBF207E0026F6C7A19F2ACFB7A60804FC98A4BFFD7BFFF2B
9529E6D9D4238002BBC255BC62959D6F3381FE06E0621B879D5FE5B541D45A1E
759A6E7DC32B1D1632368D09A97039DF255B6492B1B2B7E2C1434E8306ECA7D3
5A79B6D614B4979F10988BC76ED53A5F45315CD7DA216221F842FD0F3E050DD2
BAC23C984D506D8F7D614BCB6B244F5F41321549BB0BD041FBF3053307168680
3435E9C9456846433DF6235D79BA455E54E35184F4202D2AD4DBCC9086AB4D2F
3B2C1DA49AA410AE64858C16FD318CA45493975E6A258AA5DFC29467FC0F5367
D745F97D7DE5E26454780A91A314C65DB5F2B52CDE25210680C97D17FA2CB478
F1743947A8620E58E5DA8DA691CDD2C4616D89003ABF24562110EE69C4CA8C36
C42BA20260086BD3A76F887022674648F91831818140BAC22BE9744F0C989864
31102DE89AF744C6A4C47F6FBD40B470F55AD4C24B9FD5FA58E2024AE6129CC8
573C26470503169BEAABFB44F8D9A380F11E495E5FE493354879D9EB8AFED17F
2963C09BE9C38B13538AED05B53A4EF9BABA14C1FD49381DDB9D845305B300FC
200AD0E7C2C5AA2C4C43BB77048744047475E7AD7857458329AA8FBA10AF4BAA
E37BE56D0AABB43ABD9E4A5BA8DC6B7C25B1111CA0F345357274C1A7E7AE8365
B44C0B85072B85BEDA5B3CF98DB246AFDA27B530E6602A7CEF43743DE4EC40AE
6A82AE88FF7695F31ED1D4D5D0C11DA0635EC1C5A00B394CE71A60444DBD345E
2920A05DD75C9FD7990BCDA70FA0C968B860BA665812B8632813D613ED7F5776
6A4B07E66440470AE19D0DC34D6AF0E8BCE6685BE7DFD542478EBAB1A5EA8416
6FBC99DB5DB59A6DE46FA80A4C3EAD7E921E6ADAFB8DA021CD7D9E8218F87E21
66941A9FE9CB3F150A1E375CA59C6A0FECC67C16320007146A8EC283637D36EB
9BE29E76E758CBA9889A9D4921EF36C4F62F5CA1A2BF7D58909FC3D55254CB9E
C0B0F263A3DA47498F6B7C12EC32DC741DB8B069BCE0A8F8CC6A15DCEB09663E
0EAFECC5C5405888480951FCB41D485D10D29173C4117359589B0B72AD8B7309
5C
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMR9
%!PS-AdobeFont-1.1: CMR9 1.0
%%CreationDate: 1991 Aug 20 16:39:59
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMR9) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
end readonly def
/FontName /CMR9 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 45 /hyphen put
dup 46 /period put
dup 48 /zero put
dup 49 /one put
dup 50 /two put
dup 51 /three put
dup 52 /four put
dup 53 /five put
dup 54 /six put
dup 55 /seven put
readonly def
/FontBBox{-39 -250 1036 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5CF7158F1163BC1F3352E22A1452E73FECA8A4
87100FB1FFC4C8AF409B2067537220E605DA0852CA49839E1386AF9D7A1A455F
D1F017CE45884D76EF2CB9BC5821FD25365DDEA6E45F332B5F68A44AD8A530F0
92A36FADB679CF58BAFDD3E51DFDD314B91A605515D729EE20C42505FD4E0835
3C9D365B14C003BC6DD352F0228A8C161F172D2551CD1C67CD0B1B21DED53203
046FAFF9B1129167921DD82C5964F9DDDFE0D2686875BD075FC81831A941F20E
C5CD90040A092E559F6D1D3B0E9BB71733595AE0EA6093F986377A96060BF12A
A1B525CD9FA741FE051DD54A32BECD55A868DD63119A4370F8322CCBEC889BC2
A723CB4015FC4AA90AE873EA14DE13382CA9CF0D8DFB65F0ABEDFD9A64BB3F4D
731E2E1C9A1789228FF44116230A70C339C9819676022AB31B5C9C589AE9094B
09882051AD4637C1710D93E8DD117B4E7B478493B91EA6306FDB3FA6D738AAB1
49FBB21A00AC2A999C21445DE3177F21D8B6AAB33869C882613EA6B5EC56476B
5634181ECBF03BFEDB57F079EACE3B334F6F384BDF9D70AEBD592C8ECF21378B
54A8B5DBF7CB9282E16AA517E14843909339B5E7C55B038BF3BB493F3B884A1C
C25F9E8FB912CBE23199AD9D2C3E573727701BA301526C66C3617B9514D6F11F
11930B1D97C17816C85B1BFD9B973A191B33CC3B391815AD14F1CBE935942AEC
D4004E6BEF379066FD72209DC88D2E634E79BCC2B98C766CBD92C561F2703F8A
109E6C6CEC7B866F2FC7ADF646BF492E520319F3B949AB5D84AE990B33344A40
3971F58DFDF8D8D67FA0B8F2A0D884F8C09A5A721319B911DBA0A35903877343
C37BC36C5EB32353272D1E6ED5FCA611BE319A7E1E842CB7576E7F57C4F43525
58BBDDBF843D36F01726CADD8F200C06682EA442DA5AB9F38F178C3FA104D19D
C8EF31DA0D57CAC11D770B11C4EE619C96FC72E2054CE903000EA2FA95EE0D4D
174B7B9C9C8E2DFA414E77482C218556FE6499A237EED744B3FB4BB37AABDF99
0080D906A75A687273CFF26F08BA8DBF8B938085C8F09C300B631318DB2DC0AE
50EF6A266E52F63862C5B53DCB978D3FC2181E76A411FD131149CDBE96D8F90C
EA2854F92CA4913ED789386BB682187EFB38630E3A3DE68358F9EBD2B7206EEF
96947A94B0B9680FDEE2C6A5F6E400B528284B4B441968AF8D71EBC2F89DD602
49B1F89460321893FA3F75128DA5AD8B5EAC761CCC6BFC4C9D0BA235E63599A0
157677FDB0524D4E17860C0D9AF052702D78642C764A0A07E7563ED41BBEA979
5ABC815A8E3FB7AE6E99D98E6B8B59DC9F574CC34CDD8729DB6BAC969EEF94AE
1F57951B347D3CE5E67463985DBC5E79FAF7A82B3790E9F13B3AF8FAAE53843E
BB8023E091BB7FF39DACE70BDF2D98B55FE54D7A7E7DD1DC26FC8B579E9EBF2A
A569C43402F55649A576E43A758D587F45E9833CE20F3F2BD09E06C4A7D90A82
09D4D1BBF2244E627BDA68975E385FB3C8B17D12B859BDE305DF64927A6FB806
056CBBC93F5307F77B5287B9AB712C74704F472B89B8D20657171894BDB39205
7F64AD7557D6F0D5CE96BF8AB2E454505F12E0D0E2469C4D1B17F1562AC04ACA
BBA73462BC8904CC02ED7BA30833693A4C39591A4966EBEBB014BCCB58195AC7
CD209A50E31F517CCC36F6071BC8197C4FFB2D64292A34209562AE27271F17B6
BB75B7AD5DC7802A1B09CC994E3624318A11953B7C706B9E00953DA389DC9B88
26FC1B44BD1C90937AB8F349B9FA15E225F7F41C912E8013F39DB210C467998E
6AD6215F1DAEFE52CDF76C7CC60EC1055E7CB2145FF7D6872BE7AD43CC0CA03B
9F0F42EA8C93E18A2A2A7AF3C3C5D61C38B45CEFCDA8F1B212A73537396A1A42
68A56B82C5A0BFF9B6087339A946B57B4E7488F9F34FF9D4393B6BD51795AB16
549E0FF0A45B151A5686894F92C2B85975EAFCD2B3A79E5E3E540F426A652207
77CDD5DEE3AB590241CC20978184363026E0BF96A077BA992EDFF0B2134B4701
04C8ACAFE9BB699ECCA558ED869176A8D696841598B62FCECCD4D8281C52563A
89BEDED2790CBB1650BBB6D692B0204E07254107E2C5622FBD8BAC1A1B17BCCE
920F77589464739908F83232058CE996D6FDE43463FE410EA443D4ED61DD306F
605A43C1AEA40B83141A95224B92433E60E55D29295A8F7EEB3F1C785AD62860
2977D0F68CA84D27066106978B002FEA386CC819F993C299FD020AC1039AC91E
D540F160D0A2339E2060972B5CDB87852EB1C7DAFF2678F24E358C67E03E5870
252F691BFB03FFD1EBAA3D07749F843BC2CAE15040A71BBCD2B7A279D5F3CCDB
CD48A989E329A8C0852B8091070755199D2BF9388CD6F110F5B0F08C7ADEDB10
761F7010D26F25852DAFB7C5819FF02DFA72E7C737C5031969B6B641EBF9A9CE
E5E377522242FA4854845D203D221C1EC2B9B7E53AA6A8AF22E7F2BBCBC0EF19
B278BC59F4DB8C463899BDDD3B3B5F0ADC7390353CB8F6D60EEDF095AEB3A706
3073FA0E9E0A3B1FB708DC321234B15EF67A98962E3D10631D3D293EE1ED5AF1
511917AD88F2319348CCFBC02C69B7E5ADC0090144966E4D74CDF16C1D9C0FEB
E9AD02F42DA7D450B9E66619D77ECDC86D0BE1A1A35D465732CFBBABA7B58BBB
BC795587E9FD04F84551D68B6904B56AD61AEBB8894BEB780FFCF09F139A21AF
8AB6DBC718AD7917E632E6E15B627D6E6F12455EF298481145F8D0B38AE27293
8E449E44B9B6A9A58E3AE6902F589025E68B9E0D2A7255ED17ADC5CC19795CDE
4C7A997EFDB6874F44403035DAE7EBF1954D38A04B0C69B63BED0E7713C4DB24
94C61C32547F303CDDE1263F57E49C208D2594A6420F19AD9F4CD3F9A7B73F96
9B7A9E79C10E8D6570B848A155DC58A0D5299E8FB548D91518A9396C76D6EB44
D6A88BE96684BFD8FEC9432E2AFF38B4951437585F8F0C7EFEEFF9F2BA29F6F5
2AF891C21CE08BF02F0BE35A0D0087AB39447C79865EEDD19BC9D3C4B3508223
1012C3E27B8CC404BB1DA5D00B3E631F764C74368C112F1696C695A7768E3FED
52BD30CD8C7FFF9E103C0EB8B484A713EB40CB59B36080E946099F27
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600
(fig-bifurcacion-rounded.dvi) @start /Fa 144[31 111[{}1
49.8132 /CMMI6 rf /Fb 252[32 3[{}1 49.8132 /CMSY6 rf
/Fc 135[44 39[49 80[{}2 74.7198 /CMMI9 rf /Fd 200[38
38 38 38 38 38 38 38 1[21 26 45[{}10 74.7198 /CMR9 rf
end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
410 1211 a @beginspecial 72 @llx 72 @lly 432 @urx 180
@ury 3600 @rwi @setspecial
%%BeginDocument: bifurcacion-rounded.eps
%%!PS-Adobe-3.0 EPSF-3.0
%%Title: (bifurcacion-rounded.eps)
%%Creator: gnuplot 4.0 patchlevel 0
%%CreationDate: Fri Apr 27 12:37:24 2007
%%BoundingBox: 72 72 432 180
%%EndComments
/Gpdict 100 dict def
Gpdict begin
/Color false def
/Dashed false def
/Gplinewidth 20.000 def
/hpt_ 100.000 def
/vpt_ 100.000 def
 /hpt hpt_ def  
 /vpt vpt_ def  
 /Gppointsize_ 1 def 
 /Gplinewidth_ 1 def 
  
 /ArrowDict 25 dict def  
  
 /M /moveto load def  
 /L /lineto load def  
 /R /rmoveto load def  
 /V /rlineto load def  
 /N {newpath moveto} bind def  
 /f {rlineto fill} bind def  
 /ED { exch def} bind def  
  
 /Atan {/atan load stopped {pop pop 0} if } def  
 /Div {dup 0 eq { pop } { div } ifelse } def  
 /Pyth {dup mul exch dup mul add sqrt} def  
  
 %Sizes  
 /Gpsetlinewidth  
 { 
   dup 
 %  /Gplinewidth_ ED %save 
   Gplinewidth mul setlinewidth 
 } def  
  
 /Gpsetpointsize   
 {  
   dup  
   /Gppointsize_ ED %save 
   dup  
   vpt_ mul /vpt ED 
   hpt_ mul /hpt ED  
 } def  
      
 %Color  
 /SetHsbColor { Color {sethsbcolor} {pop pop pop} ifelse } def  
 /SetCmykColor { Color {setcmykcolor} {pop pop pop pop} ifelse } def  
 /SimpleSetColor {6 div 1 1 SetHsbColor} def  
 /Black {0 0 0 0 SetCmykColor} def  
 /Red {0 SimpleSetColor} def  
 /Blue {1 1 0 0 SetCmykColor} def  
 /Cyan {1 0 0 0 SetCmykColor} def  
 /Magenta {0 1 0 0 SetCmykColor} def 
  
 %Stroking  
 /PathLength@ % z = z + sqrt{(x-xlast)^2 + (y-ylast)^2}  
  {  
    /z   
    z  
    y ylast sub  
    x xlast sub  
    Pyth  
    add  
    def   
    /ylast y def  
    /xlast x def  
  } def  
      
  /PathLength  
  {  
    flattenpath  
    /z 0 def  
    { %move  
      /ystart ED  
      /xstart ED  
      /xlast xstart def  
      /ylast ystart def  
    }  
    { %line  
      /y ED  
      /x ED  
      PathLength@  
    }  
    { %curve  
    }  
    { %close  
      /x xstart def  
      /y ystart def  
      PathLength@   
    }  
    /pathforall load  
    stopped {pop pop pop pop} if  
    z  
  } def  
    
 %dotsep DotLine  
 /DotLine   
 {  
   PathLength /b ED   
   /z ED   
   /y currentlinewidth def   
   /z y z add def   
   [ 0 b b z Div round Div dup 0 le { pop 1 } if] 0 setdash   
   1 setlinecap  
 } def  
  
 /DashLine   
  {  
    PathLength /b ED   
    /x ED   
    /y ED   
    /z y x add def   
    b y sub z Div round z mul y add b exch Div 
    dup  
    y mul /y ED   
    x mul /x ED   
    x 0 gt y 0 gt and   
    { [ y x ] 0 }  
    { [ 1 0 ] 0 }  
    ifelse  
    setdash  
  } def  
  
 /DashLineTwo 
  {  
    PathLength /b ED   
    /u ED 
    /v ED 
    /x ED   
    /y ED 
    /z y x add u add v add def   
    b y sub z Div round z mul y add b exch Div 
    dup  
    y mul /y ED   
    x mul /x ED   
    x 0 gt y 0 gt and   
    { [ y x v u] 0 }  
    { [ 1 0 ] 0 }  
    ifelse  
    setdash  
  } def  
      
  
 /DotLineStroke   
 {  
   gsave  
     Dashed {currentlinewidth 2 mul DotLine} if  
     stroke  
   grestore  
 } def  
    
 /SolidLineStroke  
 {  
   gsave  
     [] 0 setdash  
     stroke  
   grestore  
 } def  
    
 /DashLineStroke  
 {  
   gsave   
     Dashed {Gplinewidth 8 mul Gplinewidth 5 mul DashLine} if  
     stroke  
   grestore  
 } def  
   
 /DashDotLineStroke  
 {  
   gsave   
     Dashed {Gplinewidth 8 mul Gplinewidth 5 mul 0 Gplinewidth 5 mul DashLineTwo} if  
     stroke  
   grestore  
 } def  
    
 /DashShortLineStroke  
 {  
   gsave   
     Dashed {Gplinewidth 4 mul dup DashLine} if  
     stroke  
   grestore  
 } def  
    
 /ArrowHead  
 {   
   currentlinewidth mul add dup 2 div /w ED  
   mul dup /h ED  
   mul /a ED   
   w neg h moveto   
   0 0 L   
   w h L   
   w neg a neg rlineto   
   gsave fill grestore   
 } def  
    
  %/DrawArrowHead {1 dup scale 0.2 1.4 50 3 ArrowHead} def  
  %%%%%  
  %inset length dim num  
  %arrowwidth = dim + num*linewidth  
  %arrowlength = length*arrowwidth  
  %arrowinset = width * inset  
    
  /DrawArrowHead {0.2 1.4 Gplinewidth 3 mul 4 ArrowHead} def  
    
  /Arrow  
  {  
    currentpoint  
    4 2 roll  
    ArrowDict  
    begin  
      /@mtrx matrix currentmatrix def  
      gsave  
        2 copy translate  
        2 index sub neg exch  
        3 index sub exch Atan  
        rotate  
        newpath  
        DrawArrowHead  
        @mtrx setmatrix  
        currentpoint  
      grestore  
    end %ArrowDicht  
    lineto  
    Gpstroke  
  } def  
    
  %axis  
  /LTa   
  {  
    Gpstroke      
    newpath  
    0 setgray  
    /Gpstroke {DotLineStroke newpath} def  
  } def  
    
  %border  
  /LTb  
  {  
    Gpstroke      
    newpath  
    0 setgray  
    /Gpstroke {SolidLineStroke newpath} def  
  } def  
    
  /LT0  
  {  
    Gpstroke      
    newpath  
    Red  
    /Gpstroke {SolidLineStroke newpath} def  
  } def  
    
  /LT1  
  {  
    Gpstroke      
    newpath  
    Blue  
    /Gpstroke {DashLineStroke newpath} def  
  } def  
    
  /LT2   
  {  
    Gpstroke  
    newpath  
    Cyan  
    /Gpstroke {DashShortLineStroke newpath} def  
  } def  
  
  /LT3   
  {  
    Gpstroke  
    newpath  
    Magenta  
    /Gpstroke {DashDotLineStroke newpath} def  
  } def  
    
  /Pnt  
  {  
    gsave   
      [] 0 setdash  
      1 setlinecap   
      Gplinewidth Gppointsize_ mul setlinewidth 
      M  
      0 0 V  
      stroke  
    grestore  
  } def  
    
  /DiaPath  
  {  
      [] 0 setdash  
      Gplinewidth setlinewidth  
      2 copy   
      newpath  
      vpt add moveto  
      hpt neg vpt neg rlineto   
      hpt vpt neg rlineto  
      hpt vpt rlineto   
      hpt neg vpt rlineto  
      closepath  
  } def  
    
  /Dia   
  {   
    gsave  
      DiaPath  
      stroke  
    grestore  
  } def  
    
  /DaF  
  {  
    gsave  
      DiaPath  
      fill  
    grestore  
  } def  
    
  /Crc  
  {  
    gsave  
      [] 0 setdash  
      Gplinewidth setlinewidth  
      newpath  
      vpt 0.85 mul 0 360 arc  
      closepath  
      stroke  
    grestore  
  } def  
        
    
  /Crs  
  {  
    gsave  
      [] 0 setdash  
      Gplinewidth setlinewidth  
      0 setlinecap  
      newpath  
      vpt sub  
      moveto  
      0 vpt 2 mul rlineto  
      hpt vpt neg rmoveto  
      hpt 2 mul neg 0 rlineto  
      stroke  
    grestore  
  } def  
    
  /CrX  
  {  
  gsave  
   translate  
   45 rotate  
   0 0 Crs  
  grestore  
  } def  
    
  /CcF  
  {  
    gsave  
      [] 0 setdash  
      Gplinewidth setlinewidth  
      newpath  
      vpt 0.85 mul 0 360 arc  
      closepath  
      fill  
    grestore  
  } def  
    
  /Box  
  {  
     gsave  
       translate  
       45 rotate  
       0 0 DiaPath  
       stroke  
     grestore  
  } def  
    
  /BxF  
  {  
     gsave  
       translate  
       45 rotate  
       0 0 DiaPath  
       fill  
     grestore  
  } def  
    
  /Gpstroke {stroke} def  
  1 setlinecap  
  1 setlinejoin 
 %
 % PostScript level 2 pattern fill definitions
 % Ethan A Merritt April 2003
 %
 % Level-1 compatible emulation for rectfill
  /RF { gsave newpath 4 -2 roll moveto dup 0 exch rlineto
    exch 0 rlineto neg 0 exch rlineto closepath fill grestore
  } bind def
  /BoxFill { gsave RF fill grestore } def 
  /Blank { 0 0 M 0 8 L 8 8 L 8 0 L 0 0 L
           1.0 setgray fill 0.0 setgray 0.5 setlinewidth } bind def
  /Tile8x8 { /PaintType 1 def /PatternType 1 def /TilingType 1 def
             /BBox [0 0 8 8] def /XStep 8 def /YStep 8 def
  } bind def
  /P1D 12 dict def P1D begin
      Tile8x8 /PaintProc { Blank 0 0 M 8 8 L 0 8 M 8 0 L stroke } def
  end P1D matrix makepattern
  /Pattern1 exch def
  /P2D 12 dict def P2D begin
      Tile8x8 /PaintProc { Blank 0 0 M 8 8 L 0 8 M 8 0 L stroke
                           0 4 M 4 8 L 8 4 L 4 0 L 0 4 L stroke } def
  end P2D matrix makepattern
  /Pattern2 exch def
  /P3D 12 dict def P3D begin
      Tile8x8 /PaintProc { Blank 0 0 M 0 8 L
                          8 8 L 8 0 L 0 0 L fill } def
  end P3D matrix makepattern
  /Pattern3 exch def
  /P4D 12 dict def P4D begin
      Tile8x8 /PaintProc { Blank -4 8 M 8 -4 L
                          0 12 M 12 0 L stroke } def
  end P4D matrix makepattern
  /Pattern4 exch def
  /P5D 12 dict def P5D begin
      Tile8x8 /PaintProc { Blank -4 0 M 8 12 L
                          0 -4 M 12 8 L stroke } def
  end P5D matrix makepattern
  /Pattern5 exch def
  /P6D 12 dict def P6D begin
      Tile8x8 /PaintProc { Blank -2 8 M 4 -4 L
                          0 12 M 8 -4 L 4 12 M 10 0 L stroke } def
  end P6D matrix makepattern
  /Pattern6 exch def
  /P7D 12 dict def P7D begin
      Tile8x8 /PaintProc { Blank -2 0 M 4 12 L
                          0 -4 M 8 12 L 4 -4 M 10 8 L stroke } def
  end P7D matrix makepattern
  /Pattern7 exch def
  /P8D 12 dict def P8D begin
      Tile8x8 /PaintProc { Blank 8 -2 M -4 4 L
                          12 0 M -4 8 L 12 4 M 0 10 L stroke } def
  end P8D matrix makepattern
  /Pattern8 exch def
  /P9D 12 dict def P9D begin
      Tile8x8 /PaintProc { Blank 0 -2 M 12 4 L
                          -4 0 M 12 8 L -4 4 M 8 10 L stroke } def
  end P9D matrix makepattern
  /Pattern9 exch def
 
end
%%%%EndProlog
Gpdict begin
gsave
72 72 translate
0.0200 0.0200 scale
0 setgray
newpath
1.000 Gpsetpointsize
1.000 Gpsetlinewidth
1.000 Gpsetlinewidth
LTb
1925 1970 M
300 0 V
Gpstroke
17175 1970 M
-300 0 V
Gpstroke
1.000 Gpsetlinewidth
LTb
1925 2610 M
300 0 V
Gpstroke
17175 2610 M
-300 0 V
Gpstroke
1.000 Gpsetlinewidth
LTb
1925 3250 M
300 0 V
Gpstroke
17175 3250 M
-300 0 V
Gpstroke
1.000 Gpsetlinewidth
LTb
1925 3890 M
300 0 V
Gpstroke
17175 3890 M
-300 0 V
Gpstroke
1.000 Gpsetlinewidth
LTb
1925 4530 M
300 0 V
Gpstroke
17175 4530 M
-300 0 V
Gpstroke
1.000 Gpsetlinewidth
LTb
1925 1650 M
0 300 V
Gpstroke
1925 4850 M
0 -300 V
Gpstroke
1.000 Gpsetlinewidth
LTb
4104 1650 M
0 300 V
Gpstroke
4104 4850 M
0 -300 V
Gpstroke
1.000 Gpsetlinewidth
LTb
6282 1650 M
0 300 V
Gpstroke
6282 4850 M
0 -300 V
Gpstroke
1.000 Gpsetlinewidth
LTb
8461 1650 M
0 300 V
Gpstroke
8461 4850 M
0 -300 V
Gpstroke
1.000 Gpsetlinewidth
LTb
10639 1650 M
0 300 V
Gpstroke
10639 4850 M
0 -300 V
Gpstroke
1.000 Gpsetlinewidth
LTb
12818 1650 M
0 300 V
Gpstroke
12818 4850 M
0 -300 V
Gpstroke
1.000 Gpsetlinewidth
LTb
14996 1650 M
0 300 V
Gpstroke
14996 4850 M
0 -300 V
Gpstroke
1.000 Gpsetlinewidth
LTb
17175 1650 M
0 300 V
Gpstroke
17175 4850 M
0 -300 V
Gpstroke
1.000 Gpsetlinewidth
LTb
1.000 Gpsetlinewidth
LTb
1925 1650 M
15250 0 V
0 3200 V
-15250 0 V
0 -3200 V
Gpstroke
LTb
LTb
1.000 Gpsetpointsize
1.000 Gpsetpointsize
1.000 Gpsetlinewidth
LT1
2796 3250 M
436 0 V
1416 0 V
1416 0 V
1416 0 V
1416 0 V
1417 749 V
1416 70 V
1416 224 V
1416 167 V
1416 128 V
Gpstroke
2796 3250 Dia
3232 3250 Dia
4648 3250 Dia
6064 3250 Dia
7480 3250 Dia
8896 3250 Dia
10313 3999 Dia
11729 4069 Dia
13145 4293 Dia
14561 4460 Dia
15977 4588 Dia
1.000 Gpsetpointsize
1.000 Gpsetlinewidth
LT1
2796 3250 M
436 0 V
1416 0 V
1416 0 V
1416 0 V
1416 0 V
1417 -749 V
1416 -70 V
1416 -224 V
1416 -167 V
1416 -128 V
Gpstroke
2796 3250 Crc
3232 3250 Crc
4648 3250 Crc
6064 3250 Crc
7480 3250 Crc
8896 3250 Crc
10313 2501 Crc
11729 2431 Crc
13145 2207 Crc
14561 2040 Crc
15977 1912 Crc
1.000 Gpsetlinewidth
LTb
1925 1650 M
15250 0 V
0 3200 V
-15250 0 V
0 -3200 V
1.000 Gpsetpointsize
Gpstroke
grestore
end
showpage
%%%%EOF

%%EndDocument
 @endspecial 621 900 a Fd(-2)621 794 y(-1)647 687 y(0)647
580 y(1)647 474 y(2)643 1045 y(0.000)190 b(0.001)g(0.002)g(0.003)g
(0.004)g(0.005)g(0.006)g(0.007)502 669 y
 gsave currentpoint currentpoint translate 90 neg rotate neg exch neg
exch translate
 502 669 a 462
687 a Fc(x)506 655 y Fb(\003)502 669 y
 currentpoint grestore moveto
 502 669 a 1953
1183 a Fc(P)2013 1151 y Fb(\003)2002 1196 y Fa(o)p Black
0 TeXcolorgray 1 TeXcolorgray 0 TeXcolorgray 1 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 1 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 0.25 TeXcolorgray
0 TeXcolorgray 0.5 TeXcolorgray 0 TeXcolorgray 0 0.1 0.95
TeXcolorrgb 0 TeXcolorgray 0 1 1 TeXcolorrgb 0 TeXcolorgray
0.75 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
